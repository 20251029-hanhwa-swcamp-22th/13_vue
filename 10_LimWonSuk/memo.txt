가상DOM 을 사용하는 이유
가상 돔을 이용해 메모리상에서 변경된 부분만 빠르게 찾아내고,
 실제 DOM 조작을 최소화하여 렌더링 성능을 최적화."

v = vue
-> "불필요한 렌더링을 막고,
 바뀐 부분만 골라서 효율적으로 업데이트하기 위해서입니다."
 -> 유지보수용의
 ---
setup(): 모든 것의 시작
ref(): 반응형 데이터 만들기
return: 화면으로 내보내기
HTML에서의 사용 (화면 렌더링)
@click: 이벤트와 함수 동작


 ---

 mount = Vue 를 Dom에 연결해주는것

 ref == 반응형(값변경) 변경시켜줌
 reactive 객체 ref 동일 (반응)

 vue model == 바뀐걸 감지

 {{}} == 보간법 ==

 프록시는 나중에 알아보자
 MVVM 패턴이 적용되어있다


 refernse == 다이나믹 밸류가 "상태가 변할"수 있으니까 계속 참조해라
(Vue 모델이 ref를 계속 참조함)
 -----
 02_attribute-binding
 셋업리턴 마운트 사용


 --
 03_class-binding

  class 는 css로 화면꾸미기 자주하는 속성

  --

  Q .  클래스 사이즈가 들어갔다 나갔다 하느냐

  액션발생 -> 흐름대로 진행

  ----
  04_multi-attribute

  const {createApp, ref} = Vue
  뷰라는 함수에서 {} 안에 두개 꺼네올거다

   createApp().mount('#app');
   여기서 만든객체를 ID가 app이라는 것에 붙이겠다

   createApp({})
   안에 값넣음

   클릭 -> 클릭 핸들러 실행 -> 리저트텍스트 가 바뀌고 -> 리저트텍스트를 참조하는곳이 바뀜



   ----

   05_condition

   v-show 디렉티브
   (숨기다 == 요소는 존재 O, 보이지 않음(display:none) )

   v-if, v-else, v-elfe 디렉티브
   (요소 생성/제거 == 코드상으로 추가 되었다가 삭제되는 모습)

   * template 태그
   (임시로 범위를 지정하는 용도)


   @click == Von

   변할땐 기존 값은 유지되고
   요소만 변한다

   변수는 순서랑 타입만 중요

   상태변수(ref, reactive)
   -> 변경 Virtual DOM(가상돔) 일부변경(업데이트)
   -> DOM 같은 부분 변경

   버츄얼돔에서 요청할때 id를 사용해서 요청 => key속성

컴포넌트를 완전히 다시 렌더링(재생성)하고 싶을 때 key 속성을 사용한다.
key를 쓰지 않으면 Vue가 기존 컴포넌트를 재사용해서 요소만 바뀌고 내부 상태는 유지된다.
-> 효율이나 안전성 측면에서 좋음
-> 다중요소 사용시 반드시 써라

a태그 == 클릭하면 이동

버튼 한번눌렀는데 두번전파되면 버블링
-> @click.stop 하면 역류 방지

---

inut 할 상황에는 v-model이용
input == 입력 감지기
(input에 저장된 값은 value에 저장된다)


.trim을 붙이면
글자사이의 공백(띄어쓰기)이 사라진다

아규먼트 는 전달인자
const bubblingFn = () =>  console.log("ㄴㄴss");
이라면
매개변수 bubblingFn인 아규먼트 를넣으면
console.log 반환된다